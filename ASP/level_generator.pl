distance(X1, Y1, X2, Y2, D) :-
	D is sqrt((X2-X1)^2 + (Y2 - Y1)^2).


% This satisfies all pairs X-Y for X and Y from 0 to 5
pairs(N, R) :-
	succ(N0, N),
	bagof(P, pair(N0, P), R).

pair(N, X-Y) :-
	between(0, N, X),
	between(0, N, Y).


% This adds the additional constraint that 
shape_pos(X, Y) :-
	pairs(6, R),
	member(X-Y, R).

% Originally, we added modulo constraints to specify that X/Y should be multiples of 5
% However, this is actually not necessary and semi-complicates things
% 0 is mod(X, 5),
% 0 is mod(Y, 5).

initial_shape(T, X, Y) :-
    member(T, ['cross', 'corner', 'line', 'empty']),
    shape_pos(X, Y).



initial_shapes([initial_shape(_, CX, CY) | R], CX, CY, SX, SY, EX, EY) :-
	NX is CX-1,
	NX >= 0,
	shape_pos(EX, EY),
	initial_shapes(R, NX, CY, SX, SY, EX, EY).

initial_shapes([initial_shape(_, CX, CY)], CX, CY, SX, SY, EX, EY) :-
	SX is CX,
	(EX \= SX; EY \= SY),
	distance(SX, SY, EX, EY, D),
	D > 5.

% Distance constraint above should technically allow for arbitrary start/end points
% but we discovered this is actually semi-complicated and could make for poor level generation if not done properly
% Due to this, we assume that SX, SY, EX, EY (i.e. the starting and ending points) are 0, 0, and 5, 5 respectively
% for the 5x5 grid this works on	

agg_shapes(CX, CY, SX, SY, EX, EY, [R0 | R]) :-
	CY >= 0,
	initial_shapes(R0, CX, CY, SX, SY, EX, EY),
	NY is CY-1,
	agg_shapes(CX, NY, SX, SY, EX, EY, R).

agg_shapes(CX, SY, SX, SY, EX, EY, R) :-
	CX >= 0,
	EY >= 0,
	initial_shapes(R, CX, EY, SX, SY, EX, EY).

% Board state should be generated by calling agg_shapes(EX, EY, SX, SY, EX, EY, R), where EX, EY is the endpoint (top right corner)
% and SX, SY is your starting point (bottom left corner). R is the aggregated list of each row,
% so each output should have 5 rows each with five elements
